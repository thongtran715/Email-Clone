{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = jsonFetch;\nObject.defineProperty(exports, \"retriers\", {\n  enumerable: true,\n  get: function get() {\n    return _retriers.default;\n  }\n});\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nrequire(\"isomorphic-fetch\");\n\nvar _promiseRetry = _interopRequireDefault(require(\"promise-retry\"));\n\nvar _get_request_options = _interopRequireDefault(require(\"./get_request_options\"));\n\nvar _retriers = _interopRequireDefault(require(\"./retriers\")); // eslint-disable-line\n\n\nvar DEFAULT_RETRY_OPTIONS = {\n  retries: 0\n};\n\nvar DEFAULT_SHOULD_RETRY = function DEFAULT_SHOULD_RETRY() {\n  return false;\n};\n\nfunction jsonFetch(_x) {\n  return _jsonFetch.apply(this, arguments);\n}\n\nfunction _jsonFetch() {\n  _jsonFetch = (0, _asyncToGenerator2.default)(\n  /*#__PURE__*/\n  _regenerator.default.mark(function _callee(requestUrl) {\n    var jsonFetchOptions,\n        expectedStatuses,\n        response,\n        jsonFetchResponse,\n        _args = arguments;\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            jsonFetchOptions = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            expectedStatuses = jsonFetchOptions.expectedStatuses;\n            _context.prev = 2;\n            _context.next = 5;\n            return retryFetch(requestUrl, jsonFetchOptions);\n\n          case 5:\n            response = _context.sent;\n            _context.next = 8;\n            return createJsonFetchResponse(response);\n\n          case 8:\n            jsonFetchResponse = _context.sent;\n            assertExpectedStatus(expectedStatuses, jsonFetchResponse);\n            return _context.abrupt(\"return\", jsonFetchResponse);\n\n          case 13:\n            _context.prev = 13;\n            _context.t0 = _context[\"catch\"](2);\n            _context.t0.request = getErrorRequestData({\n              requestUrl: requestUrl,\n              requestOptions: jsonFetchOptions\n            });\n            throw _context.t0;\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this, [[2, 13]]);\n  }));\n  return _jsonFetch.apply(this, arguments);\n}\n\nfunction retryFetch(_x2, _x3) {\n  return _retryFetch.apply(this, arguments);\n}\n\nfunction _retryFetch() {\n  _retryFetch = (0, _asyncToGenerator2.default)(\n  /*#__PURE__*/\n  _regenerator.default.mark(function _callee3(requestUrl, jsonFetchOptions) {\n    var shouldRetry, retryOptions, requestOptions, response;\n    return _regenerator.default.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            shouldRetry = jsonFetchOptions.shouldRetry || DEFAULT_SHOULD_RETRY;\n            retryOptions = Object.assign({}, DEFAULT_RETRY_OPTIONS, jsonFetchOptions.retry);\n            requestOptions = (0, _get_request_options.default)(jsonFetchOptions);\n            _context3.prev = 3;\n            _context3.next = 6;\n            return (0, _promiseRetry.default)(\n            /*#__PURE__*/\n            function () {\n              var _ref2 = (0, _asyncToGenerator2.default)(\n              /*#__PURE__*/\n              _regenerator.default.mark(function _callee2(throwRetryError, retryCount) {\n                var res;\n                return _regenerator.default.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.prev = 0;\n                        _context2.next = 3;\n                        return fetch(requestUrl, requestOptions);\n\n                      case 3:\n                        res = _context2.sent;\n                        if (shouldRetry(res)) throwRetryError();\n                        return _context2.abrupt(\"return\", res);\n\n                      case 8:\n                        _context2.prev = 8;\n                        _context2.t0 = _context2[\"catch\"](0);\n                        _context2.t0.retryCount = retryCount ? retryCount - 1 : 0;\n                        if (_context2.t0.code !== 'EPROMISERETRY' && shouldRetry(_context2.t0)) throwRetryError(_context2.t0);\n                        throw _context2.t0;\n\n                      case 13:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2, this, [[0, 8]]);\n              }));\n\n              return function (_x5, _x6) {\n                return _ref2.apply(this, arguments);\n              };\n            }(), retryOptions);\n\n          case 6:\n            response = _context3.sent;\n            return _context3.abrupt(\"return\", response);\n\n          case 10:\n            _context3.prev = 10;\n            _context3.t0 = _context3[\"catch\"](3);\n            _context3.t0.name = 'FetchError';\n            throw _context3.t0;\n\n          case 14:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, this, [[3, 10]]);\n  }));\n  return _retryFetch.apply(this, arguments);\n}\n\nfunction createJsonFetchResponse(_x4) {\n  return _createJsonFetchResponse.apply(this, arguments);\n}\n\nfunction _createJsonFetchResponse() {\n  _createJsonFetchResponse = (0, _asyncToGenerator2.default)(\n  /*#__PURE__*/\n  _regenerator.default.mark(function _callee4(response) {\n    var responseText;\n    return _regenerator.default.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return response.text();\n\n          case 2:\n            responseText = _context4.sent;\n            return _context4.abrupt(\"return\", {\n              status: response.status,\n              statusText: response.statusText,\n              headers: response.headers,\n              text: responseText,\n              body: getResponseBody(response, responseText)\n            });\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, this);\n  }));\n  return _createJsonFetchResponse.apply(this, arguments);\n}\n\nfunction createErrorResponse(response, responseText) {\n  // do not include headers as they potentially contain sensitive information\n  return {\n    status: response.status,\n    statusText: response.statusText,\n    text: responseText\n  };\n}\n\nfunction getResponseBody(response, responseText) {\n  if (isApplicationJson(response.headers)) try {\n    return JSON.parse(responseText);\n  } catch (err) {\n    err.response = createErrorResponse(response, responseText);\n    throw err;\n  }\n  return undefined;\n}\n\nfunction isApplicationJson(headers) {\n  var responseContentType = headers.get('Content-Type') || '';\n  return /application\\/json/.test(responseContentType);\n}\n\nfunction assertExpectedStatus(expectedStatuses, jsonFetchResponse) {\n  if (Array.isArray(expectedStatuses) && !expectedStatuses.includes(jsonFetchResponse.status)) {\n    var err = new Error(\"Unexpected fetch response status \".concat(jsonFetchResponse.status));\n    err.name = 'FetchUnexpectedStatusError'; // $FlowFixMe\n\n    err.response = jsonFetchResponse;\n    throw err;\n  }\n}\n\nfunction getErrorRequestData(_ref) {\n  var requestUrl = _ref.requestUrl,\n      requestOptions = _ref.requestOptions;\n  var data = Object.assign({}, requestOptions, {\n    url: requestUrl\n  }); // do not include headers as they potentially contain sensitive information\n\n  delete data.headers;\n  return data;\n}","map":null,"metadata":{},"sourceType":"script"}