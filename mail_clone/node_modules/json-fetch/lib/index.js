"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = jsonFetch;
Object.defineProperty(exports, "retriers", {
  enumerable: true,
  get: function get() {
    return _retriers.default;
  }
});

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

require("isomorphic-fetch");

var _promiseRetry = _interopRequireDefault(require("promise-retry"));

var _get_request_options = _interopRequireDefault(require("./get_request_options"));

var _retriers = _interopRequireDefault(require("./retriers"));

// eslint-disable-line
var DEFAULT_RETRY_OPTIONS = {
  retries: 0
};

var DEFAULT_SHOULD_RETRY = function DEFAULT_SHOULD_RETRY() {
  return false;
};

function jsonFetch(_x) {
  return _jsonFetch.apply(this, arguments);
}

function _jsonFetch() {
  _jsonFetch = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(requestUrl) {
    var jsonFetchOptions,
        expectedStatuses,
        response,
        jsonFetchResponse,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            jsonFetchOptions = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
            expectedStatuses = jsonFetchOptions.expectedStatuses;
            _context.prev = 2;
            _context.next = 5;
            return retryFetch(requestUrl, jsonFetchOptions);

          case 5:
            response = _context.sent;
            _context.next = 8;
            return createJsonFetchResponse(response);

          case 8:
            jsonFetchResponse = _context.sent;
            assertExpectedStatus(expectedStatuses, jsonFetchResponse);
            return _context.abrupt("return", jsonFetchResponse);

          case 13:
            _context.prev = 13;
            _context.t0 = _context["catch"](2);
            _context.t0.request = getErrorRequestData({
              requestUrl: requestUrl,
              requestOptions: jsonFetchOptions
            });
            throw _context.t0;

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[2, 13]]);
  }));
  return _jsonFetch.apply(this, arguments);
}

function retryFetch(_x2, _x3) {
  return _retryFetch.apply(this, arguments);
}

function _retryFetch() {
  _retryFetch = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee3(requestUrl, jsonFetchOptions) {
    var shouldRetry, retryOptions, requestOptions, response;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            shouldRetry = jsonFetchOptions.shouldRetry || DEFAULT_SHOULD_RETRY;
            retryOptions = Object.assign({}, DEFAULT_RETRY_OPTIONS, jsonFetchOptions.retry);
            requestOptions = (0, _get_request_options.default)(jsonFetchOptions);
            _context3.prev = 3;
            _context3.next = 6;
            return (0, _promiseRetry.default)(
            /*#__PURE__*/
            function () {
              var _ref2 = (0, _asyncToGenerator2.default)(
              /*#__PURE__*/
              _regenerator.default.mark(function _callee2(throwRetryError, retryCount) {
                var res;
                return _regenerator.default.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.prev = 0;
                        _context2.next = 3;
                        return fetch(requestUrl, requestOptions);

                      case 3:
                        res = _context2.sent;
                        if (shouldRetry(res)) throwRetryError();
                        return _context2.abrupt("return", res);

                      case 8:
                        _context2.prev = 8;
                        _context2.t0 = _context2["catch"](0);
                        _context2.t0.retryCount = retryCount ? retryCount - 1 : 0;
                        if (_context2.t0.code !== 'EPROMISERETRY' && shouldRetry(_context2.t0)) throwRetryError(_context2.t0);
                        throw _context2.t0;

                      case 13:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2, this, [[0, 8]]);
              }));

              return function (_x5, _x6) {
                return _ref2.apply(this, arguments);
              };
            }(), retryOptions);

          case 6:
            response = _context3.sent;
            return _context3.abrupt("return", response);

          case 10:
            _context3.prev = 10;
            _context3.t0 = _context3["catch"](3);
            _context3.t0.name = 'FetchError';
            throw _context3.t0;

          case 14:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[3, 10]]);
  }));
  return _retryFetch.apply(this, arguments);
}

function createJsonFetchResponse(_x4) {
  return _createJsonFetchResponse.apply(this, arguments);
}

function _createJsonFetchResponse() {
  _createJsonFetchResponse = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee4(response) {
    var responseText;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return response.text();

          case 2:
            responseText = _context4.sent;
            return _context4.abrupt("return", {
              status: response.status,
              statusText: response.statusText,
              headers: response.headers,
              text: responseText,
              body: getResponseBody(response, responseText)
            });

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _createJsonFetchResponse.apply(this, arguments);
}

function createErrorResponse(response, responseText) {
  // do not include headers as they potentially contain sensitive information
  return {
    status: response.status,
    statusText: response.statusText,
    text: responseText
  };
}

function getResponseBody(response, responseText) {
  if (isApplicationJson(response.headers)) try {
    return JSON.parse(responseText);
  } catch (err) {
    err.response = createErrorResponse(response, responseText);
    throw err;
  }
  return undefined;
}

function isApplicationJson(headers) {
  var responseContentType = headers.get('Content-Type') || '';
  return /application\/json/.test(responseContentType);
}

function assertExpectedStatus(expectedStatuses, jsonFetchResponse) {
  if (Array.isArray(expectedStatuses) && !expectedStatuses.includes(jsonFetchResponse.status)) {
    var err = new Error("Unexpected fetch response status ".concat(jsonFetchResponse.status));
    err.name = 'FetchUnexpectedStatusError'; // $FlowFixMe

    err.response = jsonFetchResponse;
    throw err;
  }
}

function getErrorRequestData(_ref) {
  var requestUrl = _ref.requestUrl,
      requestOptions = _ref.requestOptions;
  var data = Object.assign({}, requestOptions, {
    url: requestUrl
  }); // do not include headers as they potentially contain sensitive information

  delete data.headers;
  return data;
}